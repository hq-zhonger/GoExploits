package Information

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/chromedp/chromedp"
	"github.com/golang-module/dongle"
	"github.com/imroc/req/v3"
	"github.com/projectdiscovery/subfinder/v2/pkg/resolve"
	"github.com/projectdiscovery/subfinder/v2/pkg/runner"
	"goexploits/Information/finger"
	"io"
	"log"
	"regexp"
	"strings"
	"time"
)

type Domain struct {
	finger.FinScan
	Url               string // 域名
	UrlList           []string
	SecurityTrailsApi string // ApiKey
	FofaMail          string // FofaMail
	FofaApiKey        string
	ShoDanApiKey      string   // ShoDanApi
	Subdomains        []string `json:"subdomains"`
	FingerScan        *finger.FinScan
}

// SearchSecurityTrails
func (domain *Domain) SearchSecurityTrails() {
	if domain.Url == "" || domain.SecurityTrailsApi == "" {
		return
	}

	resp, err := req.SetHeader("accept", "application/json").SetHeader("apikey", domain.SecurityTrailsApi).Get(fmt.Sprintf("https://api.securitytrails.com/v1/domain/%s/subdomains?children_only=true", domain.Url))
	if err != nil {
		return
	}

	err = json.Unmarshal([]byte(resp.String()), &domain)
	if err != nil {
		return
	}

	for _, sub := range domain.Subdomains {
		//domain.UrlList = append(domain.UrlList, fmt.Sprintf("http://%s.%s", sub, domain.Url))
		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s.%s", sub, domain.Url))
	}
}

func (domain *Domain) SearchFofa() {
	if domain.Url == "" || domain.FofaApiKey == "" {
		return
	}

	resp, err := req.Get(fmt.Sprintf("https://fofa.info/api/v1/search/all?email=%s&key=%s&qbase64=%s&fields=host&size=10000", domain.FofaMail, domain.FofaApiKey, dongle.Encode.FromString(fmt.Sprintf("domain=%s", domain.Url)).ByBase64().String()))
	if err != nil {
		return
	}
	// fmt.Println(resp.String())
	all := strings.ReplaceAll(resp.String(), "\"", "")
	all = strings.ReplaceAll(all, "[}", "")
	all = strings.ReplaceAll(all, "]}", "")
	split := strings.Split(all, ",")
	for _, x := range split {
		domain.UrlList = append(domain.UrlList, x)
	}
	// fmt.Println("2 检查成功")
}

func (domain *Domain) SearchRapidDns() {
	if domain.Url == "" {
		return
	}

	ctx, chanel := context.WithTimeout(context.Background(), time.Second*time.Duration(20))
	defer chanel()
	resp, err := req.SetContext(ctx).SetHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36").Get(fmt.Sprintf("https://rapiddns.io/subdomain/%s?full=1", domain.Url))
	if err != nil {
		return
	}

	for _, v := range regexp.MustCompile(`<td>((?:[^\s<>]+\.)+[a-zA-Z]{2,6})</td>`).FindAllStringSubmatch(resp.String(), -1) {
		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s", v[1]))
		// domain.UrlList = append(domain.UrlList, fmt.Sprintf("http://%s", v[1]))
	}
	// fmt.Println("3 检查完毕")
}

// ShoDan
func (domain *Domain) SearchShoDan() {
	if domain.Url == "" || domain.ShoDanApiKey == "" {
		return
	}

	resp, err := req.Get(fmt.Sprintf("https://api.shodan.io/dns/domain/%s?key=%s", domain.Url, domain.ShoDanApiKey))
	if err != nil {
		fmt.Println(err)
		return
	}

	type T struct {
		Subdomains []string `json:"subdomains"`
	}

	var t T

	err = json.Unmarshal(resp.Bytes(), &t)
	if err != nil {
		fmt.Println(err)
		return
	}

	for _, v := range t.Subdomains {
		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s.%s", v, domain.Url))
	}

}

// 子域名爆破 模块 内置1800w字典
func (domain *Domain) SubdomainBurst() {
	if domain.Url == "" {
		return
	}

	file, err := finger.StaticFile.ReadFile("static/domain_1800w.txt")
	if err != nil {
		fmt.Println(err)
		return
	}

	var buffer bytes.Buffer
	buffer.WriteString(string(file))

	for {
		line, err := buffer.ReadString('\n')

		if err != nil {

			return
		}

		line = strings.TrimSpace(line)

		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s", line))
	}
}

func (domain *Domain) SearchChromedp() {
	BrowserApi := []string{
		"https://www.baidu.com",  // 百度
		"https://cn.bing.com",    // 必应
		"https://fsoufsou.com",   // F搜
		"https://www.sogou.com",  // 搜狗
		"https://www.ecosia.org", // ecosia
		"https://www.so.com",     // 360搜索
		// 国外
		"https://www.google.com", // 谷歌
		"https://yandex.com",     // 俄罗斯最大
	}

	BrowserApi = append(BrowserApi, "")

	options := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", false),
	)

	allocator, cancelFunc := chromedp.NewExecAllocator(context.Background(), options...)
	defer cancelFunc()
	ctx, cancel := chromedp.NewContext(allocator, chromedp.WithLogf(log.Printf))
	defer cancel()
	ctx, cancel = context.WithTimeout(ctx, time.Second*15)
	defer cancel()

	err := chromedp.Run(ctx, domain.ChromedpDo())
	if err != nil {
		log.Fatal(err)
	}
}

func (domain *Domain) ChromedpDo() chromedp.Tasks {
	return chromedp.Tasks{
		chromedp.Navigate("https://bing.com"),
	}
}

func (domain *Domain) SearchVirustotal() {
	options := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", false),
	)

	allocator, cancelFunc := chromedp.NewExecAllocator(context.Background(), options...)
	defer cancelFunc()
	ctx, cancel := chromedp.NewContext(allocator, chromedp.WithLogf(log.Printf))
	defer cancel()
	ctx, cancel = context.WithTimeout(ctx, time.Second*120)
	defer cancel()

	var html string

	err := chromedp.Run(ctx, chromedp.Tasks{
		chromedp.Navigate(fmt.Sprintf("https://www.virustotal.com/gui/domain/%s/relations", "4399.com")),
		chromedp.ActionFunc(func(ctx context.Context) error {
			for {
				err := chromedp.WaitVisible(`document.querySelector("#view-container > domain-view").shadowRoot.querySelector("#relations").shadowRoot.querySelector("div > vt-ui-expandable.mb-3.subdomains > span > div > vt-ui-button").shadowRoot.querySelector("div")`, chromedp.ByJSPath).Do(ctx)
				if err != nil {
					fmt.Println(err)
					return err
				}

				err = chromedp.Click(`document.querySelector("#view-container > domain-view").shadowRoot.querySelector("#relations").shadowRoot.querySelector("div > vt-ui-expandable.mb-3.subdomains > span > div > vt-ui-button").shadowRoot.querySelector("div")`, chromedp.ByJSPath).Do(ctx)

				if err != nil {
					fmt.Println(err)
					return err
				}

				time.Sleep(time.Second * 5)
			}
		}),

		chromedp.Value(`document.querySelector("#view-container > domain-view").shadowRoot.querySelector("#relations").shadowRoot.querySelector("div > vt-ui-expandable.mb-3.subdomains > span > vt-ui-generic-list").shadowRoot.querySelector("div > div.tbody")`, &html, chromedp.ByJSPath),
	})

	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(html)
}

func (domain *Domain) SearchCrtSh() {
	resp, err := req.Get(fmt.Sprintf("https://crt.sh/?q=%s", domain.Url))
	if err != nil {
		return
	}

	for _, v := range regexp.MustCompile(`<TD>((?:[^\s<>]+\.)+[a-zA-Z]{2,6})</TD>`).FindAllStringSubmatch(resp.String(), -1) {
		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s", v[1]))
	}
}

func (domain *Domain) SearchSubfinder() {
	runnerInstance, err := runner.NewRunner(&runner.Options{
		Threads:            10,                       // Thread controls the number of threads to use for active enumerations
		Timeout:            30,                       // Timeout is the seconds to wait for sources to respond
		MaxEnumerationTime: 10,                       // MaxEnumerationTime is the maximum amount of time in mins to wait for enumeration
		Resolvers:          resolve.DefaultResolvers, // Use the default list of resolvers by marshaling it to the config
		ResultCallback: func(s *resolve.HostEntry) { // Callback function to execute for available host
			// log.Println(s.Host, s.Source)
		},
	})

	var buf bytes.Buffer
	err = runnerInstance.EnumerateSingleDomain(domain.Url, []io.Writer{&buf})
	if err != nil {
		domain.SearchSubfinder()
	}

	for {
		line, err := buf.ReadString('\n')
		if err != nil {
			return
		}

		domain.UrlList = append(domain.UrlList, fmt.Sprintf("https://%s", strings.TrimSpace(line)))
	}
}

func (domain *Domain) SearchDnsGrep() {
	resp, err := req.Get(fmt.Sprintf("https://www.dnsgrep.cn/subdomain/%s", domain.Url))
	if err != nil {
		log.Fatal(err)
	}

	for _, v := range regexp.MustCompile(`<td data="((?:[^\s<>]+\.)+[a-zA-Z]{2,6})">`).FindAllStringSubmatch(resp.String(), -1) {
		domain.UrlList = append(domain.UrlList, v[1])
	}
}

// 去重
func (domain *Domain) RemoveDuplicate(strSlice []string) []string {
	result := make([]string, 0, len(strSlice))
	tempMap := map[string]struct{}{}
	for _, str := range strSlice {
		if _, ok := tempMap[str]; !ok { // 利用map去重
			tempMap[str] = struct{}{}
			result = append(result, str)
		}
	}
	return result
}

func (domain *Domain) RunFinger(InformationResultChan chan [][]string) {
	if domain.Thread <= 0 {
		domain.Thread = 10
	}

	domain.UrlList = domain.RemoveDuplicate(domain.UrlList)
	domain.FingerScan = finger.NewScan(domain.UrlList, domain.Thread, "", "")
	domain.FingerScan.StartScan(InformationResultChan)
}
